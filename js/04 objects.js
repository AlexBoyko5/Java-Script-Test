//^ ================================================================================================================================
//~ОБЧИСЛЮВАЛЬНІ (computed) ВЛАСТИВОСТІ -  в JavaScript дозволяють вам динамічно визначати імена властивостей об'єкта під час його створення.

//~ Це корисно, коли ви хочете використовувати змінні або обчислювальні вирази для визначення імен властивостей.
//~Синтаксис обчислювальних властивостей виглядає так:

// Синтаксис обчислювальних властивостей
// const obj = {
//   [вираз]: значення,
//   // або
//   [вираз_для_імені_властивості](): {
//     // ...
//   }
// };

// Приклади
// const propertyName = 'dynamicProperty';
// const obj1 = {
//   [propertyName]: 'Значення для динамічної властивості',
// };

// console.log(obj1.dynamicProperty); // Виведе: Значення для динамічної властивості

// // Використання функції для обчислення імені методу
// const methodName = 'dynamicMethod';
// const obj2 = {
//   [methodName + 'WithSuffix']() {
//     console.log('Виклик динамічного методу');
//   },
// };

// obj2.dynamicMethodWithSuffix(); // Виведе: Виклик динамічного методу

//^ ================================================================================================================


//!====================  Перебір об'єкта, Цикл for...in, Метод Object.keys(), Object.values()  =============================================

//Перебери об'єкт apartment, використовуючи метод Object.keys() і цикл for...of.
//Запиши у змінну keys масив ключів властивостей об'єкта apartment,і додай в масив values всі значення його властивостей.

// const apartment = {
//   descr: "Spacious apartment in the city center",
//   rating: 4,
//   price: 2153,
// };
// const values = [];
// /*Використовуємо Object.keys() для отримання масиву ключів властивостей об'єкта*/
// const keys = Object.keys(apartment);
// /*Цикл for...of для перебору масиву ключів*/
// for (const key of keys) {
//   /*Додаємо значення кожної властивості до масиву values*/
//   values.push(apartment[key]);
// }
//^ ===============================================
//Виконай рефакторинг функції countProps(object), замінивши перебір ключів за допомогою циклу for…in на метод Object.keys()
//для отримання масиву властивостей.
//Функція має повернути кількість властивостей в об'єкті object.

// function countProps(object) {
//   let propCount = 0;

//   for (const key in object) {
//     if (object.hasOwnProperty(key)) {
//       propCount += 1;
//     }
//   }
//   return propCount;
// }

// // РЕШЕНИЕ !
// function countProps(object) {
//   const keys = Object.keys(object);
//   return keys.length;
// }
//^ ============================================
//Запиши у змінну keys масив ключів властивостей об'єкта apartment, а у змінну values - масив їх значень.
//Використовуй методи Object.keys() і Object.values().
// const apartment = {
//   descr: "Spacious apartment in the city center",
//   rating: 4,
//   price: 2153,
// };

// const keys = Object.keys(apartment);;
// const values = Object.values(apartment);
//^ ==============================================

//!=======================  Object.values()  ==============================================================================

//Функція countTotalSalary(salaries) приймає об'єкт зарплат (salaries) в якості параметра.
// Кожна властивість об'єкта salaries — це ключ, що містить ім'я співробітника, та значення - його відповідна зарплатня.
//Доповни код функції countTotalSalary(salaries) так, щоб вона повертала загальну суму зарплат всіх співробітників.
//Поради:
//Ініціалізуй змінну totalSalary зі значенням 0, яка буде відповідати за загальну суму зарплат усіх співробітників
//Використай метод Object.values() для отримання значень (зарплат) з об'єкта salaries
//Пройдись по отриманих значеннях за допомогою циклу та додай кожне значення до змінної totalSalary.
//Поверни totalSalary як результат

// function countTotalSalary(salaries) {
//   let totalSalary = 0;
//   const values = Object.values(salaries);
//   for (const salary of values) {
//     totalSalary += salary;
//   }
//   return totalSalary;
// }
//! 1 - Ініціалізація змінної totalSalary: Спочатку ми створюємо змінну totalSalary і присвоюємо їй значення 0.
//Ця змінна буде відповідати за загальну суму зарплат усіх співробітників.

//! 2 - const values(Object.values(salaries) Отримання масиву значень з об’єкта (salaries):
// Ми використовуємо метод Object.values(salaries), щоб отримати масив всіх значень (зарплат) з об’єкта salaries.
// Це допомагає нам отримати доступ до зарплат кожного співробітника.
// Цей метод приймає об'єкт як аргумент і повертає масив його значень (значення властивостей об'єкта).
// Object - це вбудований об'єкт в JavaScript, який має властивості та методи для роботи з об'єктами.
// values - это переменная, которая содержит массив значений перечисляемых свойств объекта salaries
// salaries - це об'єкт, який містить ім'я співробітника як ключ та відповідну зарплату як значення.
// Object.values(salaries) - Метод, який приймає об'єкт (salaries) і повертає масив його значень (в даному випадку, масив зарплат).

//! 3 - (for (const salary of values)
//salary: Це масив, який ми отримали за допомогою методу Object.values(salaries). У нашому випадку, це масив зарплат співробітників.
//for...of: Це спеціальна структура циклу , яка призначена для ітерації через значення масиву (або іншої ітерабельної структури).
//^ const salary of values - Цей синтаксис означає, що для кожного елемента (salary) в масиві (values) буде виконано наступний блок коду.=>
//^=> totalSalary += salary; - Кожне значення (salary) додається до змінної totalSalary
//Отже, кожна ітерація циклу додає зарплату кожного співробітника до загальної суми (totalSalary).
// Після завершення циклу ми отримуємо суму всіх зарплат, яка зберігається в змінній totalSalary.
//
//^ ================================================

//! ======================================= Масив об’єктів ===============================================================================
//Масив colors містить колекцію кольорів. Кожен колір представлений об'єктом і має властивості hex і rgb
// з відповідними для цього формату і кольору значеннями.
//Перебери масив об'єктів colors, використовуючи цикл for...of.
//Додай у масив hexColors значення властивостей hex, а в масив rgbColors - значення властивостей rgb з усіх об'єктів масиву colors.

// const colors = [
//   { hex: "#f44336", rgb: "244,67,54" },
//   { hex: "#2196f3", rgb: "33,150,243" },
//   { hex: "#4caf50", rgb: "76,175,80" },
//   { hex: "#ffeb3b", rgb: "255,235,59" },
// ];

// const hexColors = [];
// const rgbColors = [];

// Перебір масиву об'єктів colors за допомогою циклу for...of/
//Щоб заповнити масиви hexColors і rgbColors значеннями кольорів з масиву colors,

//Цей код пройде крізь кожен об'єкт у масиві colors, витягне значення hex та rgb і додасть їх до відповідних масивів hexColors та rgbColors.
//Результатом буде вивід двох масивів, які містять значення кольорів у форматах HEX та RGB.

//^ =================================================

// Функція getProductPrice(productName) приймає один параметр productName - назва продукту.
// Функція містить масив об'єктів products з такими властивостями, як name — ім'я товару, price — ціна і quantity — кількість.
// Доповни код функції так, щоб вона шукала об'єкт продукту з певним ім'ям (властивість name) в масиві products і повертала його ціну (властивість price).
// Якщо продукт з такою назвою не знайдений, функція повинна повертати null.

// function getProductPrice(productName) {
//   const products = [
//     { name: "Radar", price: 1300, quantity: 4 },
//     { name: "Scanner", price: 2700, quantity: 3 },
//     { name: "Droid", price: 400, quantity: 7 },
//     { name: "Grip", price: 1200, quantity: 9 },
// ];
//* Цей код перебирає масив products та порівнює ім'я кожного продукту з вказаним productName.

// for (const product of products) {
//* Порівнюємо ім'я продукту
//* product.name и product.price - это свойства объекта (product), который является элементом массива (products).
//* product.name - это свойство объекта product, которое содержит имя продукта,
//* а product.price - это свойство объекта product, которое содержит цену продукта
//* при переборі масиву (products) кожний (product) є об'єктом, який містить властивості (name, price, quantity).
//* За допомогою виразу (product.name) ви отримуєте значення властивості (name) для конкретного продукту =>
//^ => (в умові завдання, що вище)...так, щоб вона (функція) шукала об'єкт продукту з певним ім'ям\властивістю (властивість name) в масиві (products)
//* аналогічно для product.price.

//   if (product.name === productName) {
//     //* Якщо ім'я співпадає, повертаємо ціну продукту
//     return product.price;
//   }
// }
// //* Якщо не знайдено продукт із вказаним ім'ям, повертаємо null
// return null;
// }
//! ======================================= Метод об’єктів ================================

//^ ============== Зміна за посиланням ===================================
// const bookShelf = {
//     books: ["The Last Kingdom"],
//     getBooks() {
//         return this.books;
//     },
//     addBook(bookName) {
//         this.books.push(bookName);
//     }
// };
// bookShelf.addBook("The Mist");
// bookShelf.addBook("Dream Guardian");
// console.log(bookShelf.getBooks());

// //*const bookShelf = {
//     //^Здесь создается (ОБЪЕКТ) с именем bookShelf.
//     //^Он содержит свойства(в данном случае books) и
//     //^методы(в данном случае getBooks и addBook).
// //*books: ["The Last Kingdom"],
//     //^Массив книг:
//     //^Внутри объекта bookShelf есть свойство books,
//     //^которое представляет собой массив книг.
//     //^В данном случае, массив начинается с книги "The Last Kingdom".
// //*getBooks() {
//         //^ getBooks - это метод объекта bookShelf,
//         //^который возвращает массив книг, хранящийся в свойстве (books.)
//         //^(this) в данном контексте ссылается на сам объект bookShelf.
// //*     return this.books;},
//  //* addBook(bookName) {
//         //^addBook - это метод объекта bookShelf,
//         //^который принимает аргумент bookName и добавляет его в конец массива books.
//         //^Таким образом, этот метод предназначен для добавления новых книг на полку.
// //*this.books.push(bookName);
// //*     }
// //*};
// //^Добавление книг на полку:
// //^Здесь вызываются методы addBook для добавления
// //^ двух новых книг("The Mist" и "Dream Guardian") на полку.
// //*bookShelf.addBook("The Mist");
// //*bookShelf.addBook("Dream Guardian");
// //*console.log(bookShelf.getBooks());

// const atTheOldToad = {
//   potions: ["Speed potion", "Stone skin"],
//   getPotions() {
//     return this.potions;
//   },
//   addPotion(potionName) {
//     this.potions.push(potionName);
//   },
// };
// //^ ========================================
// const bookShelf = {
//   books: [
//     { title: "The Last Kingdom", rating: 8 },
//     { title: "The Mist", rating: 6 }
//   ],
//   getBooks() {
//     return this.books;
//   }
// };

//% Объявление объекта:
//  const bookShelf = {
//   1 - Создается объект с именем bookShelf.
// В данном случае, объект представляет книжную полку.

//  2 - Массив книг:

// books: [
//     { title: "The Last Kingdom", rating: 8 },
//     { title: "The Mist", rating: 6 }
//   ],
//   Внутри объекта bookShelf есть свойство books, представляющее собой массив объектов.
//   Каждый объект в массиве представляет одну книгу
//   и содержит свойства title(название книги) и rating(рейтинг книги).
//  В данном примере на полке уже есть две книги: "The Last Kingdom" с рейтингом 8 и "The Mist" с рейтингом 6.

// 3 - Метод getBooks:

//     getBooks() {
//     return this.books;
//   }
// getBooks - это метод объекта bookShelf, который возвращает массив книг, хранящихся в свойстве books.
//    Таким образом, этот метод предназначен для получения списка книг на полке.

// 4 - Использование объекта:

// console.log(bookShelf.getBooks());
// Здесь вызывается метод getBooks для получения текущего списка книг на полке,
//  и результат выводится в консоль.

// В итоге, этот код представляет объект, моделирующий книжную полку.
// Он содержит информацию о книгах(название и рейтинг) и предоставляет метод для получения списка книг.

//! ============== Масив об’єктів ==========================================================================
//^ ============== Перебор масиву та повернення значень (return) ===========================================


// const atTheOldToad = {
//   potions: [
//     { name: "Speed potion", price: 460 },
//     { name: "Stone skin", price: 520 },
//   ],
//   getPotions() {
//     return this.potions;
//   },
//   addPotion(newPotion) {
//     this.potions.push(newPotion);
//   },
//   getTotalPrice() {
//     let totalPrice = 0;

//     for (const potion of this.potions) { //^В этой строке начинается цикл for...of.
//        //^Он предназначен для итерации по каждому элементу массива this.potions (т.е. там где ...potions: []....)
//       //^ Переменная potion принимает значение текущего элемента массива
//       //^ (например при первой итерации (name: "Speed potion", price: 460)) на каждой итерации.
//       totalPrice += potion.price;
//     }

//     return totalPrice;
//   },
// };

// //*const atTheOldToad = {
// //^Здесь создается объект atTheOldToad, который представляет лавку зелий

// //*potions: [
// //*{ name: "Speed potion", price: 460 },
// //*{ name: "Stone skin", price: 520 },],
// //^ Внутри объекта atTheOldToad есть свойство potions, представляющее собой [массив объектов].
// //^ Каждый объект представляет одно зелье и содержит свойства name(название зелья) и price(цена зелья).

// //*getPotions() {
// //*return this.potions;},
// //^ getPotions - это метод объекта atTheOldToad, который возвращает массив зелий, хранящихся в свойстве potions.

// //*addPotion(newPotion) {
// //*this.potions.push(newPotion);},
// //^ addPotion - это метод объекта atTheOldToad, который принимает параметр newPotion (новое зелье)
// //^ и добавляет его в конец массива зелий в свойстве potions.

// //*getTotalPrice() {
// //*let totalPrice = 0;
// //*for (const potion of this.potions) {
// //*totalPrice += potion.price;}
// //*return totalPrice;},
// //^ getTotalPrice - это метод объекта atTheOldToad,
// //^ который вычисляет и возвращает общую стоимость всех зелий в массиве potions.
// //^ Используется цикл for...of, чтобы пройти по каждому зелью и сложить цены.
// //?============================================================================================================================

//^ ============== Зміна об'єкта в масиві ============================================================================

//  Об'єкт atTheOldToad має наступні властивості:
// potions — масив об'єктів зілль
// getPotions() — метод, який повертає значення властивості potions
// updatePotionName() — метод, який приймає два параметра рядків oldName і newName
// Доповни метод updatePotionName(oldName, newName) таким чином,
// щоб він оновлював назву зілля з oldName на newName в масиві зілля у властивості potions.

// const atTheOldToad = {
//   potions: [
//     { name: "Speed potion", price: 460 },
//     { name: "Stone skin", price: 520 },
//   ],
//   getPotions() {
//     return this.potions;
//   },
//   updatePotionName(oldName, newName) {
//     for (const potion of this.potions) {
//       if (potion.name === oldName) {
//         potion.name = newName;
//       }
//     }
//   },
// };

// Після першого виклику методу atTheOldToad.updatePotionName("Stone skin", "Invisibility"),
// у властивості potions буде масив[{ name: "Speed potion", price: 460 }, { name: "Invisibility", price: 520 }]
// Після другого виклику методу atTheOldToad.updatePotionName("Speed potion", "Polymorth"),
// у властивості potions буде масив[{ name: "Polymorth", price: 460 }, { name: "Invisibility", price: 520 }]
//?============================================================================================================================

//^ ============== Синтаксис spread і rest ===================================================================================

//  Використовуючи синтаксис залишкових параметрів, доповни код функції add() так, щоб вона приймала
//  будь - яку кількість аргументів у параметр args і повертала їхню суму.
//  Для збирання аргументів у змінну args у підписі функції використовується синтаксис залишкових параметрів
//  Виклик add(15, 27) повертає 42
//  Виклик add(12, 4, 11, 48) повертає 75
//  Виклик add(32, 6, 13, 19, 8) повертає 78

//      function add(...args) { //^   Функція add приймає будь - яку кількість аргументів та повертає їхню суму
//      let sum = 0;

//      for (let i = 0; i < args.length; i++) { //^  Цикл для обчислення суми всіх аргументів
//      sum += args[i];
//        }
//        return sum;
//  }

//^ ============== Збір частини аргументів  ======================================================================================

// Функція addOverNum() приймає довільну кількість аргументів чисел.
// Доповни код функції таким чином, щоб вона обчислювала суму тільки тих аргументів,
//   які більші за задане число.Це число завжди буде передано першим аргументом.
// Для вирішення цього завдання тобі потрібно зробити наступне:
// Перший параметр value повинен представляти задане число,
//   а решта аргументів повинні бути зібрані за допомогою синтаксису(...args)
// Усередині функції ініціалізуй змінну для зберігання загальної суми
// Потім пройдись по кожному аргументу за допомогою циклу
// Перевір, чи кожен аргумент більший за вказане число, і якщо так, додай його до загальної суми
// На завершення поверни загальну суму

// function addOverNum(value, ...args) {
//   // Ініціалізуємо змінну для зберігання загальної суми
//   let sum = 0;

//   // Проходимо по кожному аргументу за допомогою циклу
//   for (let i = 0; i < args.length; i++) {
//     // Перевіряємо, чи кожен аргумент більший за вказане число
//     if (args[i] > value) {
//       // Якщо так, додаємо його до загальної суми
//       sum += args[i];
//     }
//   }

//   // Повертаємо загальну суму
//   return sum;
// }

// (i < args.length): Це умова продовження циклу.
// Цикл буде продовжуватися, поки значення лічильника(i) менше довжини масиву(args.)
// Отже, у виразі(i < args.length), args.length визначає кількість елементів у масиві args.
// Цикл виконується для кожного індексу від 0 до(args.length - 1), включно.
// Це забезпечує проходження через всі елементи масиву args.
//   (args[i]): Це значення елемента масиву args за індексом(i).
//   У кожній ітерації циклу for, (i) змінюється, відповідно(args[i])
//    отримує значення елемента масиву на поточному індексі(i).
//   Отже, вираз(args[i] > value) перевіряє, чи поточний елемент масиву(за індексом i) більший за значення value.
//   Якщо це умова виконується, то відповідний елемент додається до загальної суми у функції addOverNum.

//^ ============== Входження параметрів  ===========================================================================================

// Функція getExtremeScores(scores) приймає масив оцінок(чисел) у параметрі scores.
// Доповни код функції так, щоб вона повертала об'єкт із двома властивостями:
// Властивість best має містити найбільше число з масиву scores
// Властивість worst має містити найменше число з масиву scores.
// Використовуй оператор(...spread) і методи Math.max() і Math.min().

// function getExtremeScores(scores) {
//   const best = Math.max(...scores);
//   const worst = Math.min(...scores);
//   return { best, worst };
// }

// // Використовуємо spread-оператор для передачі елементів масиву (scores) як аргументів для методів Math.max() і Math.min().
// // const best - це властивість параметру (scores)
// // Math.max(...scores); - це знаення властивості (best), тобто метод Math.max()
// // (...spread) - це оператор розпилення, для застосування у методі Math.max()

// const best = Math.max(...scores);
// const worst = Math.min(...scores);

// Масив(scores) може мати, наприклад, таке значення:
// const scores = [75, 92, 88, 64, 97, 82];
// Spread - оператор дозволяє передати кожен елемент масиву(scores), тобто значення 75, 88, 64...
//  як окремий аргумент, для методів Math.max() та Math.min() де вони будуть обчислюватись.

//^ ============== Створення масиву  ===============================================================================

// У змінних firstGroupScores, secondGroupScores і thirdGroupScores зберігаються результати тестування окремих груп.Використовуючи розпилення, доповни код таким чином, щоб:
// У змінній allScores зберігався масив всіх результатів від першої до третьої групи включно.
// У змінній bestScore був найвищий загальний бал.
// У змінній worstScore був найнижчий загальний бал.

// const firstGroupScores = [64, 42, 93];
// const secondGroupScores = [89, 14, 51, 26];
// const thirdGroupScores = [29, 47, 18, 97, 81];

// const allScores = [...firstGroupScores,
// ...secondGroupScores,
// ...thirdGroupScores];

// const bestScore = Math.max(...allScores);
// const worstScore = Math.min(...allScores);

<<<<<<< Updated upstream
//! ============== ПЕРЕБИРАЮЧІ МЕТОДИ МАСИВІВ  =======================================================================
//^ ============== Колбек-функції =============================================================================

//? ============== Функція як значення ==========================================================================
// Функція makePizza повертає рядок з повідомленням клієнту.
// Доповни код таким чином, щоб у змінній result був результат виконання функції makePizza,
// а у змінній pointer було посилання на функцію makePizza.

// function makePizza() {
//   return "Your pizza is being prepared, please wait.";
// }

// const result = makePizza();
// const pointer = makePizza;
//? =============//? =============//? =============//? =============//? =============//? =============

function greet(name) {
  console.log(`Welcome ${name}!`);
}

function notify(name) {
  console.log(`Dear ${name}, your room will be ready in 30 minutes`);
}

function registerGuest(name, callback) {
  console.log(`Registering ${name}!`);
  callback(greet);
}
registerGuest("Mango", greet);
// registerGuest("Mango", notify);

// Параметр (name) является общим для всех трех функций. При вызове, внутри функции registerGuest,
//  параметра callback(name); вместо(name) будут подставлены его значения из функций greet и notify,
// т.е. (`Welcome ${name}!`).....
// В зависимости от того, какая функция обратного вызова была передана в качестве аргумента callback,
//  вместо (name) будут подставлены соответствующие значения из функций greet или notify.
// Таким образом, если функция greet была передана в качестве аргумента callback,
// то в консоль будет выведено сообщение приветствия, а если функция notify - то сообщение уведомления.
// почему не пишут например callback(greet); или может callback(notify); ведь это та же функция ?
// если вы передадите функцию greet в качестве аргумента callback, вместо (name) то в консоль будет выведено
//  структура (тело) функции (`Welcome ${name}!`), а не его значение ("Welcome Mango!")
//  а если функцию notify - структура (тело) функции notify.

//? =============//? =============//? =============//? =============//? =============//? =============
// Функція makeMessage приймає один параметр - ім'я піци, що доставляється,(pizzaName) 
// та повертає рядок з повідомленням клієнту.
// Доповни функцію makeMessage таким чином, щоб вона очікувала другим параметром(параметр callback) колбек - функцію і
// повертала результат її виклику.
// Функції deliverPizza або makePizza будуть передаватися як колбек для makeMessage і
//  очікувати аргументом ім'я готової піци, що доставляється.

function deliverPizza(pizzaName) {
  return `Delivering ${pizzaName} pizza.`;
}

function makePizza(pizzaName) {
  return `Pizza ${pizzaName} is being prepared, please wait...`;
}

function makeMessage(pizzaName, callback) {// Виклик колбек-функції, передача їй ім'я піци як аргумент
  const message = callback(pizzaName)
  return message;
}
Вариант 2

function deliverPizza(pizzaName) {
  return `Delivering ${pizzaName} pizza.`;
}
function makePizza(pizzaName) {
  return `Pizza ${pizzaName} is being prepared, please wait...`;
}
function makeMessage(pizzaName, callback) {
  return callback(pizzaName);
}
//? =============//? =============//? =============//? =============//? =============//? =============

//^ ============== Інлайн - колбеки ================================================================================

// Функція makePizza має два параметри: pizzaName - ім'я піци та callback - колбек-функцію.
// Під час виконання, makePizza викликає цей колбек, передаючи йому pizzaName як аргумент.
// Доповни другий виклик функції makePizza(pizzaName, callback), передавши другим аргументом
// інлайн колбек - функцію eatPizza(pizzaName).Колбек eatPizza логує рядок "Eating pizza <назва піци>",
// де < назва піци > це значення параметра pizzaName.

function makePizza(pizzaName, callback) {
  console.log(`Pizza ${pizzaName} is being prepared, please wait...`);
  callback(pizzaName);
}

makePizza("Royal Grand", function deliverPizza(pizzaName) {
  console.log(`Delivering pizza ${pizzaName}`);
});

makePizza("Ultracheese", function eatPizza(pizzaName) {
  console.log(`eatPizza ${pizzaName}`);
});
//? =============//? =============//? =============//? =============//? =============//? =============

//^ ============== Метод forEach(callback) =================================================================
