//^  Оголоси змінну fruits. Надай змінній fruits наступне значення: масив фруктів - рядків "apple", "plum", "pear" і "orange".
//^ Оголошена змінна fruits
//^ Значення змінної fruits - це масив ["apple", "plum", "pear", "orange"]

// const fruits = ["apple", "plum", "pear", "orange",];
//! ========================================================================================
//*Оголоси три змінні і надай кожній змінній відповідне значення, використовуючи нотацію квадратних дужок.
//^ Ім'я змінної	Значення змінної
//^firstElement-перший елемент масиву
//^ secondElement-другий елемент масиву
//^ lastElement-останній елемент масиву
//^  Значення змінної firstElement - це рядок "apple"
//^  Значення змінної secondElement - це рядок "plum"
//^  Значення змінної lastElement - це рядок "orange"

// const fruits = ["apple", "plum", "pear", "orange"];
// const firstElement = fruits[0];
// const secondElement = fruits[1];
// const lastElement = fruits[3];
//! ==========================================================================================================================
//*Виконай перевизначення значення елементів з індексами 1 і 3. Заміни "plum" на "peach", а "orange" на "banana".
//^Оголошена змінна fruits
//^Значення змінної fruits - це масив ["apple", "peach", "pear", "banana"]

// const fruits = ["apple", "plum", "pear", "orange"];
// fruits[1] = "peach";
// fruits[3] = "banana";
//! ==========================================================================================================================
//*Функція getOrderQuantity(order) приймає один параметр order - масив рядків, які описують продукти в замовленні клієнта.
//*Доповни код функції таким чином, щоб вона повертала число, що дорівнює кількості елементів масиву.
//^Виклик getOrderQuantity(["apple", "peach", "pear", "banana"]) повертає 4
//^Виклик getOrderQuantity(["apple", "banana"]) повертає 2
//^Виклик getOrderQuantity(["apple", "banana", "pear"]) повертає 3
//^Виклик getOrderQuantity([]) повертає 0

// function getOrderQuantity(order) {
//   return order.length;
// }
//! =========================================================================================================================
//*Функція getLastElementMeta(array) приймає один параметр array - масив довільних значень.
//*Доповни код функції таким чином, щоб вона повертала новий масив з двох елементів:
//*перший елемент - це індекс останнього елементу у масиві array
//*другий елемент - це значення останнього елементу у масиві array
//^Виклик getLastElementMeta(["apple", "peach", "pear", "banana"]) повертає [3, "banana"]
//^Виклик getLastElementMeta(["apple", "peach", "pear"]) повертає [2, "pear"]
//^Виклик getLastElementMeta(["apple", "peach"]) повертає [1, "peach"]
//^Виклик getLastElementMeta(["apple"]) повертає [0, "apple"]

// function getLastElementMeta(array) {
//   // Отримуємо індекс останнього елементу
//   const lastElementIndex = array.length - 1;
//   // Отримуємо значення останнього елементу у масиві array
//   const lastElementItem = array[lastElementIndex];
//   // Повертаємо результат
//   return [lastElementIndex, lastElementItem];
// }
//! ========================================================================================================================
//*Функція getExtremeElements(array) приймає один параметр array - масив елементів довільної довжини.
//*Доповни код функції таким чином, щоб вона повертала масив з двох елементів - першого і останнього елементів параметра array.
//^Виклик getExtremeElements([1, 2, 3, 4, 5]) повертає [1, 5]
//^Виклик getExtremeElements(["Earth", "Mars", "Venus"]) повертає ["Earth", "Venus"]
//^Виклик getExtremeElements(["apple", "peach", "pear", "banana"]) повертає ["apple", "banana"]

// function getExtremeElements(array) {
//   const firstElement = array[0];
//   const lastElement = array[array.length - 1];
//   return [firstElement, lastElement];
// }
//! =======================================================================================================================
//~Примітиви це - рядки, числа, буль, null і undefined
//! =========================================================================================================================
//*===============================ФУНКЦИИ И ПСЕВДОМАССИВЫ====================================================================
//! =======================================================================================================================
//* Функція createReversedArray() може приймати довільну кількість аргументів.
//* Доповни код функції так, щоб вона повертала масив усіх аргументів, але в масиві вони повинні йти у зворотному порядку.
//* Тобто, при виклику createReversedArray(1, 2, 3), функція має повернути масив [3, 2, 1].
//* Використовуй цикл або метод масиву toReversed(), який застосовується до масиву
//* і результатом роботи повертає новий масив з елементами у зворотньому порядку.
//^Оголошена функція createReversedArray()
//^Виклик функції createReversedArray(12, 85, 37, 4) повертає [4, 37, 85, 12]
//^Виклик функції createReversedArray(164, 48, 291) повертає [291, 48, 164]
//^Виклик функції createReversedArray(412, 371, 94, 63, 176) повертає [176, 63, 94, 371, 412]
//^Виклик функції createReversedArray() повертає []

// function createReversedArray() {
//   let arr = Array.from(arguments);
//   return arr.toReversed();
// }
// Метод Array.from() створює новий масив, який містить копії елементів, що передаються в якості аргументів.
// Цей метод може приймати будь-яку кількість аргументів, які будуть скопійовані в новий масив.
// У функції createReversedArray(), метод Array.from() використовується для створення масиву з усіх аргументів,
// що передаються в функцію. Наприклад, якщо функція викликається з аргументами createReversedArray(1, 2, 3),
// то метод Array.from() створить масив [1, 2, 3].

//^==================================================================

// Сервісу гравірування прикрас потрібна функція, яка б автоматично рахувала ціну гравірування,
// залежно від кількості слів і ціни за слово.
// Оголошена функція calculateEngravingPrice(message, pricePerWord).
// Ця функція приймає першим параметром рядок, що складається зі слів,
//  розділених лише пробілами(параметр message) та другим параметром - число,
//  що містить ціну гравірування за одне слово(параметр pricePerWord).
// Доповни тіло функції так, щоб вона повертала загальну вартість
// гравірування усіх слів в рядку.

// function calculateEngravingPrice(message, pricePerWord) {

//     /*Розділяємо рядок на слова*/
//     const words = message.split(" ");

//     /*Знаходимо кількість слів та обчислюємо вартість гравірування*/
//     const wordCalc = words.length;
//     const totalPrice = pricePerWord * wordCalc;

//     /*Повертаємо результат*/
//     return totalPrice;
// }

//^==================================================================

// Функція calculateTotalPrice(order) приймає один параметр order - масив чисел.
// Доповни функцію так, щоб вона повертала загальну суму елементів з масиву order.

// function calculateTotalPrice(order) {
//     // створюэмо змінну для збереження загальної суми
//     let total = 0;
//     //Проходимось по всім елементам масиву order
//     for (let i = 0; i < order.length; i += 1) {
//         // Додаємо поточний елемент "i" до загальної суми
//         total += order[i];
//     }
//     return total;
// }

//^==================================================================

// Функція getEvenNumbers(start, end) має два параметри start та end,
//     які є цілими числами.Доповни код функції так, щоб вона повертала масив
// усіх парних чисел від start до end.Якщо жодного парного числа немає,
//     то масив має бути пустим.Парним вважається число,
//         яке ділиться на 2 без остачі(10 % 2 === 0).Використовуй цикл for.

// function getEvenNumbers(start, end) {
//     const evenNumbers = []; // Создаем пустой массив для хранения парных чисел
//     for (let i = start; i <= end; i++) { // Используем цикл for для перебора всех чисел от start до end
//         if (i % 2 === 0) { // Проверяем, является ли текущее число четным
//             evenNumbers.push(i); // Если число четное, добавляем его в массив evenNumbers
//         }
//     }
//     return evenNumbers; // Возвращаем массив всех парных чисел от start до end
// }

//^==================================================================

// Функція checkStorage(storage, item) приймає два параметри:
// storage - масив рядків, що описує доступні товари на складі
// item - рядок з назвою товара, наявність якого потрібно перевірити
// Доповни код функції таким чином, щоб вона перевіряла, чи присутній
// такий товар в масиві storage і повертала:

// рядок "<item> is available to order!", де item - це назва товара, якщо товар було знайдено
// рядок "Sorry! We are out of stock!", якщо такого товара немає в масиві
// Зроби так, щоб пошук за ім'ям товару був незалежний від регістру,
// тобто наприклад "plum" і "pLuM" мають бути знайдені у масиві["apple", "plum", "pear"].

// function checkStorage(storage, item) {

//     const lowerCaseItem = item.toLowerCase();

//     // Перевірка наявності товару в масиві за допомогою методу includes()
//     if (storage.includes(lowerCaseItem)) {
//         // Якщо товар знайдено, повертаємо повідомлення про доступність
//         return `${lowerCaseItem} is available to order!`;
//     }

//     // Якщо товар відсутній, повертаємо повідомлення про відсутність
//     return "Sorry! We are out of stock!";
// }

//вариант 2
// function checkStorage(storage, item) {
//     // Проходим по всем элементам массива storage
//     for (let i = 0; i < storage.length; i++) {
//         // Если текущий элемент массива (в нижнем регистре) равен искомому товару (также в нижнем регистре)
//         if (storage[i].toLowerCase() === item.toLowerCase()) {
//             // Возвращаем строку с названием товара
//             return `${storage[i]} is available to order!`;
//         }
//     }
//     // Если товар не найден, возвращаем сообщение об отсутствии товара
//     return "Sorry! We are out of stock!";
// }

//! storage[i] - это обращение к элементу массива storage по индексу i.
//! В данном случае, storage[i] используется для сравнения текущего элемента массива с искомым товаром.

//?Каждый элемент в массиве имеет свой индекс, начиная с 0.
//?Например, если у нас есть массив storage с элементами["apple", "plum", "pear"],
//?то storage[0] вернет "apple", storage[1] вернет "plum", а storage[2] вернет "pear".
//^==================================================================