//^  Оголоси змінну fruits. Надай змінній fruits наступне значення: масив фруктів - рядків "apple", "plum", "pear" і "orange".
//^ Оголошена змінна fruits
//^ Значення змінної fruits - це масив ["apple", "plum", "pear", "orange"]

// const fruits = ["apple", "plum", "pear", "orange",];
//! ========================================================================================
//*Оголоси три змінні і надай кожній змінній відповідне значення, використовуючи нотацію квадратних дужок.
//^ Ім'я змінної	Значення змінної
//^firstElement-перший елемент масиву
//^ secondElement-другий елемент масиву
//^ lastElement-останній елемент масиву
//^  Значення змінної firstElement - це рядок "apple"
//^  Значення змінної secondElement - це рядок "plum"
//^  Значення змінної lastElement - це рядок "orange"

// const fruits = ["apple", "plum", "pear", "orange"];
// const firstElement = fruits[0];
// const secondElement = fruits[1];
// const lastElement = fruits[3];
//! ==========================================================================================================================
//*Виконай перевизначення значення елементів з індексами 1 і 3. Заміни "plum" на "peach", а "orange" на "banana".
//^Оголошена змінна fruits
//^Значення змінної fruits - це масив ["apple", "peach", "pear", "banana"]

// const fruits = ["apple", "plum", "pear", "orange"];
// fruits[1] = "peach";
// fruits[3] = "banana";
//! ==========================================================================================================================
//*Функція getOrderQuantity(order) приймає один параметр order - масив рядків, які описують продукти в замовленні клієнта.
//*Доповни код функції таким чином, щоб вона повертала число, що дорівнює кількості елементів масиву.
//^Виклик getOrderQuantity(["apple", "peach", "pear", "banana"]) повертає 4
//^Виклик getOrderQuantity(["apple", "banana"]) повертає 2
//^Виклик getOrderQuantity(["apple", "banana", "pear"]) повертає 3
//^Виклик getOrderQuantity([]) повертає 0

// function getOrderQuantity(order) {
//   return order.length;
// }
//! =========================================================================================================================
//*Функція getLastElementMeta(array) приймає один параметр array - масив довільних значень.
//*Доповни код функції таким чином, щоб вона повертала новий масив з двох елементів:
//*перший елемент - це індекс останнього елементу у масиві array
//*другий елемент - це значення останнього елементу у масиві array
//^Виклик getLastElementMeta(["apple", "peach", "pear", "banana"]) повертає [3, "banana"]
//^Виклик getLastElementMeta(["apple", "peach", "pear"]) повертає [2, "pear"]
//^Виклик getLastElementMeta(["apple", "peach"]) повертає [1, "peach"]
//^Виклик getLastElementMeta(["apple"]) повертає [0, "apple"]

// function getLastElementMeta(array) {
//   // Отримуємо індекс останнього елементу
//   const lastElementIndex = array.length - 1;
//   // Отримуємо значення останнього елементу у масиві array
//   const lastElementItem = array[lastElementIndex];
//   // Повертаємо результат
//   return [lastElementIndex, lastElementItem];
// }
//! ========================================================================================================================
//*Функція getExtremeElements(array) приймає один параметр array - масив елементів довільної довжини.
//*Доповни код функції таким чином, щоб вона повертала масив з двох елементів - першого і останнього елементів параметра array.
//^Виклик getExtremeElements([1, 2, 3, 4, 5]) повертає [1, 5]
//^Виклик getExtremeElements(["Earth", "Mars", "Venus"]) повертає ["Earth", "Venus"]
//^Виклик getExtremeElements(["apple", "peach", "pear", "banana"]) повертає ["apple", "banana"]

// function getExtremeElements(array) {
//   const firstElement = array[0];
//   const lastElement = array[array.length - 1];
//   return [firstElement, lastElement];
// }
//! =======================================================================================================================
//~Примітиви це - рядки, числа, буль, null і undefined
//! =========================================================================================================================
//*===============================ФУНКЦИИ И ПСЕВДОМАССИВЫ====================================================================
//! =======================================================================================================================
//* Функція createReversedArray() може приймати довільну кількість аргументів.
//* Доповни код функції так, щоб вона повертала масив усіх аргументів, але в масиві вони повинні йти у зворотному порядку.
//* Тобто, при виклику createReversedArray(1, 2, 3), функція має повернути масив [3, 2, 1].
//* Використовуй цикл або метод масиву toReversed(), який застосовується до масиву
//* і результатом роботи повертає новий масив з елементами у зворотньому порядку.
//^Оголошена функція createReversedArray()
//^Виклик функції createReversedArray(12, 85, 37, 4) повертає [4, 37, 85, 12]
//^Виклик функції createReversedArray(164, 48, 291) повертає [291, 48, 164]
//^Виклик функції createReversedArray(412, 371, 94, 63, 176) повертає [176, 63, 94, 371, 412]
//^Виклик функції createReversedArray() повертає []

// function createReversedArray() {
//   let arr = Array.from(arguments);
//   return arr.toReversed();
// }
// Метод Array.from() створює новий масив, який містить копії елементів, що передаються в якості аргументів.
// Цей метод може приймати будь-яку кількість аргументів, які будуть скопійовані в новий масив.
// У функції createReversedArray(), метод Array.from() використовується для створення масиву з усіх аргументів,
// що передаються в функцію. Наприклад, якщо функція викликається з аргументами createReversedArray(1, 2, 3),
// то метод Array.from() створить масив [1, 2, 3].

//^==================================================================

// Сервісу гравірування прикрас потрібна функція, яка б автоматично рахувала ціну гравірування,
// залежно від кількості слів і ціни за слово.
// Оголошена функція calculateEngravingPrice(message, pricePerWord).
// Ця функція приймає першим параметром рядок, що складається зі слів,
//  розділених лише пробілами(параметр message) та другим параметром - число,
//  що містить ціну гравірування за одне слово(параметр pricePerWord).
// Доповни тіло функції так, щоб вона повертала загальну вартість
// гравірування усіх слів в рядку.

// function calculateEngravingPrice(message, pricePerWord) {

//     /*Розділяємо рядок на слова*/
//     const words = message.split(" ");

//     /*Знаходимо кількість слів та обчислюємо вартість гравірування*/
//     const wordCalc = words.length;
//     const totalPrice = pricePerWord * wordCalc;

//     /*Повертаємо результат*/
//     return totalPrice;
// }

//^==================================================================

// Функція calculateTotalPrice(order) приймає один параметр order - масив чисел.
// Доповни функцію так, щоб вона повертала загальну суму елементів з масиву order.

//  function calculateTotalPrice(order) {
// let total = 0; // Ініціалізуємо змінну total зі значенням 0
// for (let i = 0; i < order.length; i++) { // Перебираємо всі елементи масиву order
//     total += order[i];// Додаємо кожен елемент до total
// }
// return total;
// }

// В предоставленном коде есть цикл, который перебирает все элементы массива order,
// и на каждой итерации добавляет значение текущего элемента(order[i]) к переменной total.
// Цикл продолжается до тех пор, пока условие i < order.length не станет ложным,
//     что означает прохождение через все элементы массива.

// Вот пошаговое объяснение кода:
// let i = 0: Инициализирует переменную i значением 0.
// Эта переменная используется в качестве индекса для доступа к элементам массива.
//     i < order.length: Это условие для продолжения цикла.
// Оно проверяет, является ли текущее значение i меньше длины массива order.
//     total += order[i]: Добавляет значение элемента с индексом i в массиве order к переменной total.
// Эта операция выполняется на каждой итерации цикла.
//             i++: Увеличивает значение i на 1 после каждой итерации, переходя к следующему элементу массива.
// Таким образом, order[i] - это способ доступа к значению элемента текущего индекса i в массиве order.
// Цикл обеспечивает повторение этой операции для каждого элемента массива,
//     эффективно суммируя все значения в массиве и сохраняя результат в переменной total.


//^==================================================================

// Функція getEvenNumbers(start, end) має два параметри start та end,
//     які є цілими числами.Доповни код функції так, щоб вона повертала масив
// усіх парних чисел від start до end.Якщо жодного парного числа немає,
//     то масив має бути пустим.Парним вважається число,
//         яке ділиться на 2 без остачі(10 % 2 === 0).Використовуй цикл for.

// function getEvenNumbers(start, end) {
//     const evenNumbers = []; // Создаем пустой массив для хранения парных чисел
//     for (let i = start; i <= end; i++) { // Используем цикл for для перебора всех чисел от start до end
//         if (i % 2 === 0) { // Проверяем, является ли текущее число четным
//             evenNumbers.push(i); // Если число четное, добавляем его в массив evenNumbers
//         }
//     }
//     return evenNumbers; // Возвращаем массив всех парных чисел от start до end
// }

// вот пошаговое объяснение кода function getEvenNumbers(start, end):

//     const evenNumber = []: Создается пустой массив evenNumber,
//         который будет использоваться для хранения четных чисел.

//     for(let i = start; i <= end; i++):
//         Начинается цикл, инициализируется переменная i значением start,
//     и цикл выполняется, пока i меньше или равно end.На каждой итерации i увеличивается на 1.

// if (i % 2 === 0) evenNumber.push(i);: Внутри цикла проверяется, является ли текущее значение i четным числом.
// Если условие выполняется(число четное), то оно добавляется в конец массива evenNumber с помощью метода push.
// Завершение цикла: После завершения цикла возвращается массив evenNumber,
//     который теперь содержит все четные числа в диапазоне от start до end.

// Таким образом, evenNumber.push(i) добавляет значение i(если оно четное)
// в конец массива evenNumber, формируя массив из четных чисел в заданном диапазоне.

//^==================================================================

// Функція checkStorage(storage, item) приймає два параметри:
// storage - масив рядків, що описує доступні товари на складі
// item - рядок з назвою товара, наявність якого потрібно перевірити
// Доповни код функції таким чином, щоб вона перевіряла, чи присутній
// такий товар в масиві storage і повертала:

// рядок "<item> is available to order!", де item - це назва товара, якщо товар було знайдено
// рядок "Sorry! We are out of stock!", якщо такого товара немає в масиві
// Зроби так, щоб пошук за ім'ям товару був незалежний від регістру,
// тобто наприклад "plum" і "pLuM" мають бути знайдені у масиві["apple", "plum", "pear"].

// function checkStorage(storage, item) {

//     const lowerCaseItem = item.toLowerCase();

//     // Перевірка наявності товару в масиві за допомогою методу includes()
//     if (storage.includes(lowerCaseItem)) {
//         // Якщо товар знайдено, повертаємо повідомлення про доступність
//         return `${lowerCaseItem} is available to order!`;
//     }

//     // Якщо товар відсутній, повертаємо повідомлення про відсутність
//     return "Sorry! We are out of stock!";
// }
//?=========================================
//вариант 2
// function checkStorage(storage, item) {
//     // Проходим по всем элементам массива storage
//     for (let i = 0; i < storage.length; i++) {
//         // Если текущий элемент массива (в нижнем регистре) равен искомому товару (также в нижнем регистре)
//         if (storage[i].toLowerCase() === item.toLowerCase()) {
//             // Возвращаем строку с названием товара
//             return `${storage[i]} is available to order!`;
//         }
//     }
//     // Если товар не найден, возвращаем сообщение об отсутствии товара
//     return "Sorry! We are out of stock!";
// }

//! storage[i] - это обращение к элементу массива storage по индексу i.
//! В данном случае, storage[i] используется для сравнения текущего элемента массива с искомым товаром.

//?Каждый элемент в массиве имеет свой индекс, начиная с 0.
//?Например, если у нас есть массив storage с элементами["apple", "plum", "pear"],
//?то storage[0] вернет "apple", storage[1] вернет "plum", а storage[2] вернет "pear".

//^==================================================================

// Функція getCommonElements(array1, array2), приймає два масиви(array1 та array2)
// довільної довжини в якості параметрів.
// Доповни код функції:

// Створи порожній масив для зберігання нового масиву.
// Використай цикл for для ітерації кожного елемента у array1.
// У тілі циклу перевір, чи поточний елемент існує у array2 за допомогою методу includes.
// Якщо він існує, то додай елемент до нового масиву.
// Поверни наповнений масив спільних елементів як результат роботи функції.

// function getCommonElements(array1, array2) {
//     // Створення масиву для збереження нового масиву
//     const commonElements = [];

//     for (let i = 0; i < array1.length; i += 1)
//     // Цикл for, щоб перевірити  ітерації кожного елемента у array1
//     {
//         if (array2.includes(array1[i])) // Перевірка чи поточний елемент існує у array2

//             commonElements.push(array1[i]); // Якщо елемент існує, додати його до нового масиву CommonElements
//     }
//     return commonElements;
// }
//^==================================================================

// Доповни код функції calculateTotalPrice(order) так, щоб вона повертала загальну суму чисел в масиві order.
// Використай цикл for...of для перебору масиву.

// function calculateTotalPrice(order) {
//     // створюэмо змінну для збереження загальної суми
//     let totalPrice = 0;
//     // Перебір елементів у масиві за допомогою циклу for...of
//     for (const item of order) {
//         // Додаємо поточний елемент "item" до загальної суми
//         totalPrice += item;
//     }
//     return totalPrice;
// }

// totalPrice += item; - это форма записи для увеличения значения
// переменной totalPrice на значение переменной item.
// В данной функции calculateTotalPrice, эта операция выполняется внутри цикла for...of,
//     который перебирает все элементы в массиве order.
// На каждой итерации текущий элемент массива(item) добавляется
// к существующему значению переменной totalPrice.
// результате выполнения этого кода totalPrice
// будет содержать сумму всех элементов массива order.